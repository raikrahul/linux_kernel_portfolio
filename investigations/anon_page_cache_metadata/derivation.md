# Investigation: Anonymous vs File Pages

**Date**: 2025-12-29
**Subject**: Page Types & The Mapping Pointer
**Machine**: x86_64

---

## 1. Axiomatic Foundation

### Two Types of Memory
*   **AXIOM**: Data in RAM either comes from a File (Persistent) or is generated by the Program (Volatile).
*   **FILE PAGE**: Backed by a file on disk. (e.g., Code, `mmap`'d files).
*   **ANON PAGE**: "Anonymous" because it has no file name. (e.g., Stack, Heap `malloc`).

## 2. Derivation: The Mapping Tag

How does the kernel distinguish them using `page->mapping`?

*   **POINTER ALIGNMENT**: `struct address_space` is always aligned to at least 4 bytes (ends in `00` binary).
*   **TRICK**: Use the Least Significant Bit (LSB).
    *   **LSB = 0**: Pointer is valid `struct address_space *`. **FILE PAGE**.
    *   **LSB = 1**: Pointer is `anon_vma` + 1. **ANON PAGE**.

### The Logic
```c
if ((unsigned long)page->mapping & PAGE_MAPPING_ANON) {
    type = ANONYMOUS;
    real_ptr = page->mapping - 1;
} else {
    type = FILE;
    real_ptr = page->mapping;
}
```

## 3. Experiment: Bitwise Inspection

*   [anon_check.c](https://github.com/raikrahul/linux_kernel_portfolio/blob/main/investigations/anon_page_cache_metadata/anon_file_hw.c): Module to inspect `page->mapping` of different memory areas.
*   **OBSERVATION**:
    *   Trace `malloc` area: `mapping` ends in `1` (Odd). -> Anon.
    *   Trace `mmap(file)` area: `mapping` ends in `0` (Even). -> File.

## 4. Conclusion
The kernel exploits pointer alignment axioms to store type information in the pointer itself. A single bit distinguishes the volatile scratchpad of the Heap from the persistent cache of the Filesystem.
